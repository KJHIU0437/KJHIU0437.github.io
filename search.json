[{"title":"Go 的包管理方式","url":"/2019/12/17/Go-的包管理方式/","content":"\nGo 的包管理方式是逐渐演进的， 最初是 monorepo 模式，所有的包都放在 GOPATH 里面，使用类似命名空间的包路径区分包，不过这种包管理显然是有问题，由于包依赖可能会引入破坏性更新，生产环境和测试环境会出现运行不一致的问题。\n\n从 v1.5 开始开始引入 vendor 包模式，如果项目目录下有 vendor 目录，那么 go 工具链会优先使用 vendor 内的包进行编译、测试等，这之后第三方的包管理思路都是通过这种方式来实现，比如说由社区维护准官方包管理工具 dep。\n\n不过官方并不认同这种方式，在 v1.11 中加入了 Go Module 作为官方包管理形式，就这样 dep 无奈的结束了使命。最初的 Go Module 提案的名称叫做 vgo，下面为了介绍简称为 gomod。不过在 v1.11 和 v1.12 的 Go 版本中 gomod 是不能直接使用的。可以通过 go env 命令返回值的 GOMOD 字段是否为空来判断是否已经开启了 gomod，如果没有开启，可以通过设置环境变量 export GO111MODULE=on 开启。\n\n目前 gomod 在 Go v1.12 功能基本稳定，到下一个版本 v1.13 将默认开启，是时候开始在项目中使用 gomod 了。\n\nHello,World\nGo 维护者 Russ Cox 写一个简单的库，用于说明 gomod 的使用，下文我将使用这个库开始介绍。\n\n首先在个人包命名空间目录新建一个文件夹，然后直接使用 go mod init 即可。\n```sh\nmkdir $GOPATH/github.com/islishude/gomodtest\ncd $GOPATH/github.com/islishude/gomodtest\ngo mod init\n```\n更新：现在不允许在 GOPATH 下使用 gomod，需要更改成以下命令：\n```sh\nmkdir -p ~/gopher/gomodtest\ncd ~/gopher/gomodtest\ngo mod init github.com/islishude/gomodtest\n```\n这时可看到目录内多了 go.mod 文件，内容很简单只有两行：\n```\nmodule github.com/islishude/gomodtest\n\ngo 1.12\n```\n首行为当前的模块名称，接下来是 go 的使用版本。这两行和 npm package.json 的 name 和 engine 字段的功能很类似。\n\n然后新建一个 main.go 写入以下内容，这里我们引用了 rsc.io/quote 包，注意我们现在还没有下载这个包。\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"rsc.io/quote\"\n)\n\nfunc main() {\n\tfmt.Println(quote.Hello())\n}\n```\n如果是默认情况下，使用 go run main.go 肯定会提示找不到这个包的错误，但是当前 gomod 模式，如果没有此依赖回先下载这个依赖。\n```sh\n$ go run main.go\ngo: finding rsc.io/quote v1.5.2\ngo: finding rsc.io/sampler v1.3.0\ngo: finding golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c\ngo: downloading rsc.io/quote v1.5.2\ngo: extracting rsc.io/quote v1.5.2\ngo: downloading rsc.io/sampler v1.3.0\ngo: extracting rsc.io/sampler v1.3.0\ngo: downloading golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c\ngo: extracting golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c\nHello, world.\n```\n因为包含 golang.org 下的包，记得设置代理。这个时候当前包目录除了 go.mod 还有一个 go.sum 的文件，这个类似 npm package-lock.json。\n\ngomod 不会在 $GOPATH/src 目录下保存 rsc.io 包的源码，而是包源码和链接库保存在 $GOPATH/pkg/mod 目录下。\n```sh\n$ ls $GOPATH/pkg/mod\ncache      golang.org rsc.io\n```\n除了 go run 命令以外，go build、go test 等命令也能自动下载相关依赖包。\n\n包管理命令\n当然我们平常都不会直接先写代码，写上引入的依赖名称和路径，然后在 build 的时候在下载。\n\n安装依赖\n如果要想先下载依赖，那么可以直接像以前那样 go get 即可，不过 gomod 下可以跟语义化版本号，比如 go get foo@v1.2.3，也可以跟 git 的分支或 tag，比如go get foo@master，当然也可以跟 git 提交哈希，比如 go get foo@e3702bed2。需要特别注意的是，gomod 除了遵循语义化版本原则外，还遵循最小版本选择原则，也就是说如果当前版本是 v1.1.0，只会下载不超过这个最大版本号。如果使用 go get foo@master，下次在下载只会和第一次的一样，无论 master 分支是否更新了代码，如下所示，使用包含当前最新提交哈希的虚拟版本号替代直接的 master 版本号。\n```sh\n$ go get golang.org/x/crypto/sha3@master\ngo: finding golang.org/x/crypto/sha3 latest\ngo: finding golang.org/x/crypto latest\n$ cat go.mod\nmodule github.com/adesight/test\n\ngo 1.12\n\nrequire (\n\tgolang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect\n\trsc.io/quote v1.5.2\n)\n```\n如果下载所有依赖可以使用 go mod download 命令。\n\n升级依赖\n查看所有以升级依赖版本：\n```sh\n$ go list -u -m all\ngo: finding golang.org/x/sys latest\ngo: finding golang.org/x/crypto latest\ngithub.com/adesight/test\ngolang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a [v0.0.0-20190316082340-a2f829d7f35f]\ngolang.org/x/text v0.3.0\nrsc.io/quote v1.5.2\nrsc.io/sampler v1.99.99\n```\n升级次级或补丁版本号：\n```\ngo get -u rsc.io/quote\n```\n仅升级补丁版本号：\n```\ngo get -u=patch rscio/quote\n```\n升降级版本号，可以使用比较运算符控制：\n```\ngo get foo@'<v1.6.2'\n```\n移除依赖\n当前代码中不需要了某些包，删除相关代码片段后并没有在 go.mod 文件中自动移出。\n\n运行下面命令可以移出所有代码中不需要的包：\n```\ngo mod tidy\n```\n如果仅仅修改 go.mod 配置文件的内容，那么可以运行 go mod edit --droprequire=path，比如要移出 golang.org/x/crypto 包\n```\ngo mod edit --droprequire=golang.org/x/crypto\n```\n查看依赖包\n可以直接查看 go.mod 文件，或者使用命令行：\n```sh\n$ go list -m all\ngithub.com/adesight/test\ngolang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a\ngolang.org/x/text v0.3.0\nrsc.io/quote v1.5.2\nrsc.io/sampler v1.99.99\n$ go list -m -json all # json 格式输出\n{\n        \"Path\": \"golang.org/x/text\",\n        \"Version\": \"v0.3.0\",\n        \"Time\": \"2017-12-14T13:08:43Z\",\n        \"Indirect\": true,\n        \"Dir\": \"/Users/lishude/go/pkg/mod/golang.org/x/text@v0.3.0\",\n        \"GoMod\": \"/Users/lishude/go/pkg/mod/cache/download/golang.org/x/text/@v/v0.3.0.mod\"\n}\n{\n        \"Path\": \"rsc.io/quote\",\n        \"Version\": \"v1.5.2\",\n        \"Time\": \"2018-02-14T15:44:20Z\",\n        \"Dir\": \"/Users/lishude/go/pkg/mod/rsc.io/quote@v1.5.2\",\n        \"GoMod\": \"/Users/lishude/go/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.mod\"\n}\n```\n模块配置文本格式化\n由于可手动修改 go.mod 文件，所以可能此文件并没有被格式化，使用下面命令进行文本格式化。\n```\ngo mod edit -fmt\n```\n发布版本\n发布包新版本和其它包管理工具基本一致，可以直接打标签，不过打标签之前需要在 go.mod 中写入相应的版本号：\n```\n$ go mod edit --module=github.com/islishude/gomodtest/v2\n$ cat go.mod\nmodule github.com/islishude/gomodtest/v2\n\ngo 1.12\n\nrequire (\n\tgolang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect\n\trsc.io/quote v1.5.2\n)\n```\n官方推荐将上述过程在一个新分支来避免混淆，那么类如上述例子可以创建一个 v2 分支，但这个不是强制要求的。\n\n还有一种方式发布新版本，那就是在主线版本种加入 v2 文件夹，相应的也需要内置 go.mod 这个文件。\n\n比如上述我们引入的 rsc.io/quote 包，其中 v3 版本是用内置文件夹，而 v2 使用的是 tag。\n```\n$ tree .\n.\n├── LICENSE\n├── README.md\n├── buggy\n│   └── buggy_test.go\n├── go.mod\n├── go.sum\n├── quote.go\n├── quote_test.go\n└── v3\n    ├── go.mod\n    ├── go.sum\n    └── quote.go\n$ git tag -a\nbad\nv1.0.0\nv1.1.0\nv1.2.0\nv1.2.1\nv1.3.0\nv1.4.0\nv1.5.0\nv1.5.1\nv1.5.2\nv1.5.3-pre1\nv2.0.0\nv2.0.1\nv3.0.0\nv3.1.0\n(END)\n```\n根据上面的说明，想必你会看到一个问题，当我们升级主版本号的时候，要更改 module 名称，也就是上面所说的加上版本号，这就存在一个问题，如果我们要更新到主版本号的依赖就没有这么简单了，因为升级的依赖包路径都需要修改，这个在其它语言包管理以及 Go 第三方包管理工具都不存在的一点。\n\n如下所示，升级 rsc.io/quote 到 v3 版本。注意一点，作为例子这里包作者对函数也加上了版本，其实大部分人是不会加的。这个模式叫做 semantic import versioning，也是备受争议，大多数人认为这个没有特别大的作用，而维护者则认为这是为了 Go 下一个十年的必要条件。\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"rsc.io/quote/v3\"\n)\n\nfunc main() {\n\tfmt.Println(quote.HelloV3())\n}\n```\n对于内部开发我觉得还挺好，让大家都了解，不要随意加入破坏性更新。\n\n不过由于这个不讨喜功能，不同版本可以存在同一个包了。补充一句，对于 v0 和 v1 版本并不需要加入到 import path 内。\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\tq1 \"rsc.io/quote\"\n\t\"rsc.io/quote/v3\"\n)\n\nfunc main() {\n\tfmt.Println(quote.HelloV3())\n\tfmt.Println(q1.Hello())\n}\n```\n从老项目迁移\n从很多第三方的包管理工具直接迁移到 gomod 特别简单，直接运行 go mod init 即可。\n\n如果没有使用任何第三方包管理工具，除了运行 go mod init 初始化以外，还要使用 go get ./... 下载安装所有依赖包，并更新 go.mod 和 go.sum 文件。\n\n默认情况下，go get 命令使用 @latest 版本控制符对所有依赖进行下载，如果想要更改某一个包的版本，可以使用 go mod edit --require 命令，比如要更新 rsc.io/quote 到 v3.1.0 版本。\n```\ngo mod edit --require=rsc.io/quote@v3.1.0\n```\n阅读更多\n上面说到 dep 这个社区维护的准官方管理工具无奈结束使命被 gomod 替代，关于这段故事，你可以阅读这篇文章：《关于 Go Module 的争吵》\n\n更多介绍：\n\n[官方维基](https://github.com/golang/go/wiki/Modules)\n\n[跳出 Go Module 的泥潭](https://colobu.com/2018/08/27/learn-go-module/)\n\n[初窥Go module](https://tonybai.com/2018/07/15/hello-go-module/)\n\n[原文](https://github.com/isLishude/blog/issues/195)","tags":["GO"]},{"title":"nginx缓存设置与浏览器缓存机制","url":"/2019/12/13/nginx缓存设置与浏览器缓存机制/","content":"\n# nginx 缓存设置\n## 协商缓存\n不配置默认\n\n## 强缓存\n```nginx\nlocation ~ .*\\.(css|js|swf|php|htm|html )$ {\n    add_header Cache-Control public;\n    expires max;\n}\n```\n此设置会使通过超链接或直接在浏览器地址栏输入url的请求使用Disk Cache缓存，返回200，不向服务器发送任何请求，而浏览器刷新会使用协商缓存，向服务器请求，查询缓存是否可用，若可用返回304 Not Modified，没有响应体，使用本地缓存渲染。\n\n## 禁用缓存\n```nginx\nlocation ~ .*\\.(css|js|swf|php|htm|html )$ {\n    add_header Cache-Control no-store;\n    add_header Pragma no-cache;\n}\n```\n\n# 浏览器缓存机制\n\n强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。","tags":["nginx"]},{"title":"Windows下将nginx配置成服务并设置开机自启动","url":"/2019/12/12/Windows下将nginx配置成服务并设置开机自启动/","content":"\n### 1. 概述\n一般有2种方法，推荐第二种。\n\n### 2. 方法一(创建服务)\n我们使用Windows Service Wrapper来为nginx创建服务，为什么不使用instsrv/servany、FireDaemon或者其他办法呢？\n\n下面是网上摘录的一段话：\n\n> 通过 instsrv/srvany(微软官方创建服务的方法) 或者 FireDaemon 的方式(来创建 Nginx 为服务)，只是启动进程，当你想要停止它时，将关闭这个进程。但这些方式都无法关闭多余的那个 nginx.exe\n> 进程。所以每次你停止/启动/重启服务都会产生一个多余的 nginx.exe 进程，不方便！\n\n从网上下载一个Windows Service Wrapper(winsw.exe)，然后复制到nginx根目录，可以随意改名字，比如我改成nginx-server.exe，然后新建一个xml文件（文件名比如和exe同名，比如我的叫nginx-server.xml），内容如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<service>\n\t<id>nginx</id>\n\t<name>nginx</name>\n\t<description>nginx server</description>\n\t<executable>D:\\GreenSoft\\nginx-1.11.8\\nginx.exe</executable>\n\t<logpath>D:\\GreenSoft\\nginx-1.11.8\\server-logs\\</logpath>\n\t<logmode>roll</logmode>\n\t<depend></depend>\n\t<startargument>-p D:\\GreenSoft\\nginx-1.11.8</startargument>\n\t<stopargument>-p D:\\GreenSoft\\nginx-1.11.8 -s stop</stopargument>\n</service>\n\n```\n\n上面的logpath指的是服务的日志，记得先手动建一个server-logs文件夹，然后执行nginx-server install就会安装成功了！我一般还习惯去服务里面把它改成延迟启动：\n\n\n\n### 3. 方法二\n方法一有一个很大的缺点，就是这种方式启动之后调用nginx -s reload命令失效，所以后来我采用了另外一种更简单的方法：\n\n发送一个nginx的快捷方式到桌面，然后把这个快捷方式移动到如下目录即可实现开机自启（注意将Administrator更改为自己的用户名）！\n\nC:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\n","tags":["nginx"]},{"title":"go入门","url":"/2019/12/10/go入门/","content":"\n# Go的相关环境变量\n\n## 打印go的所有环境变量\n```cmd\n$ go env\nset GO111MODULE=on\nset GOARCH=amd64\nset GOBIN=\nset GOCACHE=C:\\Users\\tangzuguo\\AppData\\Local\\go-build\nset GOENV=C:\\Users\\tangzuguo\\AppData\\Roaming\\go\\env\nset GOEXE=.exe\nset GOFLAGS=\nset GOHOSTARCH=amd64\nset GOHOSTOS=windows\nset GONOPROXY=*.corp.example.com\nset GONOSUMDB=*.corp.example.com\nset GOOS=windows\nset GOPATH=C:\\Users\\tangzuguo\\go\nset GOPRIVATE=*.corp.example.com\nset GOPROXY=https://goproxy.io\nset GOROOT=D:\\applications\\go\nset GOSUMDB=sum.golang.org\nset GOTMPDIR=\nset GOTOOLDIR=D:\\applications\\go\\pkg\\tool\\windows_amd64\nset GCCGO=gccgo\nset AR=ar\nset CC=gcc\nset CXX=g++\nset CGO_ENABLED=1\nset GOMOD=NUL\nset CGO_CFLAGS=-g -O2\nset CGO_CPPFLAGS=\nset CGO_CXXFLAGS=-g -O2\nset CGO_FFLAGS=-g -O2\nset CGO_LDFLAGS=-g -O2\nset PKG_CONFIG=pkg-config\nset GOGCCFLAGS=-m64 -mthreads -fmessage-length=0 -fdebug-prefix-map=C:\\Users\\TANGZU~1\\AppData\\Local\\Temp\\go-build641621094=/tmp/go-build -gno-record-gcc-switches\n```\n\n## 打印具体某一个环境变量\n```cmd\n$ go env GOPATH\n```\n\n## 变量含义\nGOROOT  表示Go语言的安装目录\nGOPATH  指定我们的开发工作区(workspace),是存放源代码、测试文件、库静态文件、可执行文件的工作。**注意，GOPATH的值不能与GOROOT相同。**\n可以在GOPATH中设置多个工作区，如：\n```cmd\nexport GOPATH=/opt/go;$home/go\n```\nGOBIN   表示我们开发程序编译后二进制命令的安装目录。\nGOOS    默认值是我们当前的操作系统， 如果windows，linux,注意mac os操作的上的值是darwin。\nGOARCH  表示CPU架构，如386，amd64,arm等。\n### GOOS和GOARCH的取值范围\nGOOS和GOARCH的值成对出现，而且只能是下面列表对应的值。\n```\n$GOOS\t    $GOARCH\nandroid\t    arm\ndarwin\t    386\ndarwin\t    amd64\ndarwin\t    arm\ndarwin\t    arm64\ndragonfly   amd64\nfreebsd\t    386\nfreebsd\t    amd64\nfreebsd\t    arm\nlinux\t    386\nlinux\t    amd64\nlinux\t    arm\nlinux\t    arm64\nlinux\t    ppc64\nlinux\t    ppc64le\nlinux\t    mips\nlinux\t    mipsle\nlinux\t    mips64\nlinux\t    mips64le\nlinux\t    s390x\nnetbsd\t    386\nnetbsd\t    amd64\nnetbsd\t    arm\nopenbsd\t    386\nopenbsd\t    amd64\nopenbsd\t    arm\nplan9\t    386\nplan9\t    amd64\nsolaris\t    amd64\nwindows\t    386\nwindows\t    amd64\n\n```\n\n### 交叉编译\n什么是交叉编译？所谓的交叉编译，是指在一个平台上就能生成可以在另一个平台运行的代码，例如，我们可以32位的Windows操作系统开发环境上，生成可以在64位Linux操作系统上运行的二进制程序。\n在其他编程语言中进行交叉编译可能要借助第三方工具，但在Go语言进行交叉编译非常简单，最简单只需要设置GOOS和GOARCH这两个环境变量就可以了。\n\n示例\n编译在64位Linux操作系统上运行的目标程序\n\n```cmd\n$ GOOS=linux GOARCH=amd64 go build main.go\n```\n\n复制代码编译arm架构Android操作上的目标程序\n\n```cmd\n$ GOOS=android GOARCH=arm GOARM=7 go build main.go\n```\n\n\n## GO开发规范\n上面的代码表示我们指定两个工作区，不过当我们使用go get命令去获取远程库的时候，一般会安装到第一个工作区当中。\n\n按照Go开发规范，GOPATH目录下的每个工作一般分为三个子目录:src,pkg,bin，所以我们看到的每个工作区是这样子的：\n```\nbin/\n    hello                      # 可执行文件\n    outyet                     # 可执行文件\nsrc/\n    github.com/golang/example/\n        .git/                 \n    hello/\n        hello.go               # 命令行代码\n    outyet/\n        main.go                # 命令行代码\n        main_test.go           # 测试代码\n    stringutil/\n        reverse.go             # 库文件\n        reverse_test.go        # 库文件\n    golang.org/x/image/\n        .git/                  \n    bmp/\n        reader.go              # 库文件\n        writer.go              # 库文件\n\n```\n\n更多GO项目结构规范参考[这里](https://www.jianshu.com/p/4726b9ac5fb1)\n\n","tags":["GO"]},{"title":"正交概念","url":"/2019/12/09/正交概念/","content":"\n> 编程中，经常出现正交这个词。正交指相互独立，不可替代，并且组合起来可实现其它功能。\n为什么相互独立，会使用正交这个词呢？\n正交，最开始是数学术语，被引到计算机领域。正交英文是 orthogonal，本意是垂直，几何概念。线性代数中，两向量正交指它们内积为 0。而函数正交，是指两个函数相乘的积分为 0。\n但就算知道这些，还是不明白正交是什么，数学上的正交概念跟编程上的正交概念有什么关系呢？\n\n## 原则\n无论什么领域，表象都是无穷无尽的，会出现各种情形。假如出现情形 A, 就单独去研究情形 A；出现情形 B, 就单独去研究情形 B，各种情形分别去解决，根本就没有尽头。\n\n人们不会单纯研究表象，而是不断简化，最终产生几条最基本的原理，和一套基本原理的组合法则。这几条原理相互独立，不可再进行简化。假如 C 原理可以用 A、B 原理组合起来表示，这样 C 原理就不是最基本的。\n\n于是知道基本原理和组合规则，其它表象就可以归结成基本原理和基本组合法则的重复推演。这样只要研究好基本原理，研究好组合规则，其它的表象可以一大批统一地解决了。\n\n## 向量正交\n相同的思路，应用到向量。\n\n所有的向量构成一个空间，而所有的向量是无穷无尽的。一个个向量分别分析也自然没有尽头。这样我们挑选几个相互独立的基本向量，再定义一套组合规则。这样其它的向量，就用基本向量组合起来表示。\n\n于是很自然地产生问题，基本向量是什么？如何才叫相互独立？组合规则是什么？\n\n对于向量空间，组合规则其实就是线性叠加。乘法和加法很基本，不同的领域常常会重新定义类似乘法的概念和类似加法的概念。在线性叠加中，类似乘法的概念，就是向量的内积，当内积为 0 表示两个向量相互独立。\n\n假设 A、B 为基本向量，C 可以用 A、B 叠加起来表示。于是\n\n```\nC = a * A + b * B\n```\n两边乘以 B，得到\n```\nC * B = a * A * B + b * B * B\n```\n这里的乘法符号其实是内积，假如 A * B = 0，就可以消去第一项，系数 b 就只和 C 和 B 有关。而当 B * B = 1 时，可以再次简化计算过程。\n\n当将二维向量几何化后，内积为 0，两个向量刚好正交（orthogonal）。另外一个术语就是平行，跟正交对应。平行表示完全相关，正交表示完全不相关，有时会处于平行是正交之间，它们的夹角可以表示相关程度。\n\n当 A * B = 0 ，A、B 正交；B * B = 1，B 标准化，也叫归一化。当正交归一的向量，作为独立的基本向量，线性叠加成其它向量。会使得计算过程大大简化。\n\n## 函数正交\n将相同的思路，应用到函数。\n\n所有函数构成函数空间，取一些基本的、正交的函数，再定义组合规则。每个具体领域，加法和乘法的含义有所不同。对于函数，类似于乘法的概念是积分。两函数的正交，就是相乘后积分为 0。当 f(x)、t(x) 作为基本函数，这样 k(x) 用两个函数叠加的方式来表示。\n\nk(x) = a f(x) + b t(x)\n这时需要求出系数 a 和 b 的。可以两边先乘以 f(x), 得出，\n\nk(x) * f(x) = a f(x) * f(x) + b t(x) * f(x)\n当 f(x) 和 t(x) 正交，两边取积分，就可以消去，t(x) * f(x)。这样系数 a 就只会跟 k(x) 和 f(x) 有关系。\n\n还可以有多个函数相互正交，甚至无限多个函数正交。比如选取 cos、sin，作为基本函数，叠加起来表示其它函数，就演变成了傅里叶变换。\n\n## 编程上的正交\n从数学上引进正交这个词，用于表示指相互独立，相互间不可替代，并且可以组合起来实现其它功能。比如 if 和 for 语句是正交的，但 for 和 while 语句的功能是有重叠的。逻辑运算 not、and、or 也是正交的，其它复杂的逻辑运算都可以用这三种基本运算叠加起来。\n\n编程语言经常定义一组正交语法特性，相互间不可替代，组合起来可以其它功能。而为了更方便使用，在基础特性之上，再添加一些额外特性。这些非基本的额外特性，称为语法糖（Syntactic sugar）。语法糖对语言的功能没有太大影响，有可以，没有也可以，但有了之后，代码写起来更方便些。\n"},{"title":"raft一致性协议详解","url":"/2019/12/09/raft一致性协议详解/","content":"\n> ","tags":["微服务"]},{"title":"consul学习笔记","url":"/2019/12/05/consul学习笔记/","content":"\n\n### 安装\n\n两种方式安装：\n1. 使用编译好的二进制文件\n2. 源码编译安装\n\n#### 使用编译好的二进制文件\n从官网下载zip包，解压，配好PATH环境变量即可。\n\n#### 源码编译安装\n需要安装GO环境，和git 用于clone源码\n\n1. clone 源码\n```\n$ mkdir -p $GOPATH/src/github.com/hashicorp && cd !$\n$ git clone https://github.com/hashicorp/consul.git\n$ cd consul\n```\n\n2. 引导项目,这将下载编译consul所需的库和工具:\n```\n$ make tools\n```\n\n3. 编译本地环境\n```\n$ make dev\n```\n\n#### 验证安装\n```\n$ consul -v\n```\n\n### Consul 会使用的端口\n\nUse|Default Ports|翻译|\n:--|--:|--:|\nDNS: The DNS server (TCP and UDP)   |8600|用于解析DNS查询|\nHTTP: The HTTP API (TCP Only)|  8500|用于和 client 交互的接口|\nHTTPS: The HTTPs API|   disabled (8501)*|(可选)在默认情况下是关闭的，但是端口8501是各种工具使用的默认约定。|\ngRPC: The gRPC API| disabled (8502)*|(可选)目前，gRPC仅用于向特使代理公开xDS API。它在默认情况下是关闭的，但是端口8502是各种工具使用的默认约定。在-dev模式下默认为8502。|\nLAN Serf: The Serf LAN port (TCP and UDP)|\t8301|这是用来处理局域网内的 gossip 消息的。所有agent 都必须有。|\nWan Serf: The Serf WAN port (TCP and UDP)|\t8302|这是服务器用来在广域网上与其他服务器gossip 消息的。从Consul v0.8广域网加入洪水功能要求Serf广域网端口(TCP/UDP)监听广域网和局域网接口。另见: [Consul v0.8.0 CHANGELOG](https://github.com/hashicorp/consul/blob/master/CHANGELOG.md#080-april-5-2017)和[GH-3058](https://github.com/hashicorp/consul/issues/3058)|\nserver: Server RPC address (TCP Only)|\t8300|服务器使用它来处理来自其他代理的传入请求。|\nSidecar Proxy Min: Inclusive min port number to use for automatically assigned sidecar service registrations.|\t21000|\nSidecar Proxy Max: Inclusive max port number to use for automatically assigned sidecar service registrations.|\t21255|\n*对于HTTPS和gRPC，建议使用表中指定的端口。\n\n\n### 引导 Datacenter （数据中心）\n\nagent 有 client 和 server 两种运行方式。server 节点负责运行[一致性协议](https://www.consul.io/docs/internals/consensus.html) 和存储集群状态。client 大多是无状态的，严重依赖server节点。\n\n在 Consul 集群可以开始服务请求之前，必须选举一个 Server 节点为leader。引导是将这些初始服务器节点连接到集群中的过程。阅读[架构文档](https://www.consul.io/docs/internals/architecture.html)以了解更多关于Consul的内部信息。\n\n建议每个数据中心拥有3到5个服务器。单个服务器部署是非常不鼓励的，因为在失败场景中数据丢失是不可避免的。有关详细信息，请参阅[部署表](https://www.consul.io/docs/internals/consensus.html#deployment-table)。\n\n> 注意:在0.4之前的版本中，bootstrapping是一个手动过程。有关直接使用`-bootstrap`标志的详细信息，请参阅手动引导文档。在更新版本的执政者(0.5和更新版本)中不推荐使用`-bootstrap`手动引导，因为它更容易出错。相反，应该使用带有`-bootstrap-expect`的自动引导。\n\n### 引导 Servers\n\n引导服务器的推荐方法是使用`-bootstrap-expect`配置选项。此选项通知 Consul 服务器节点的预期数量，并在多个服务器可用时自动引导。为了防止不一致性和分裂大脑(多个服务器认为自己是领导者的集群)的情况，您应该为-bootstrap-expect指定相同的值，或者在所有服务器上完全不指定值。只有指定值的服务器才会尝试引导集群。\n\n假设我们启动一个包含三个服务器的集群。我们可以启动节点A、节点B和节点C，每个节点都提供`-bootstrap-expect 3`标志。启动节点后，您应该会在服务输出中看到一条警告消息。\n\n```\n[WARN] raft: EnableSingleNode disabled, and no known peers. Aborting election.\n```\n\n警告表明，节点期望有2个对等节点，但还不知道。下面你将学习如何连接服务器，使一个可以被选为leader。\n\n### 创建集群\n\n您可以通过将服务器连接在一起来触发leader election，从而创建一个集群。您可以将节点配置为自动连接，也可以手动连接。\n\n#### 自动加入服务器\n\n连接服务器有多种选择。选择最适合您的环境和特定用例的方法。\n\n- 使用`-join`和`start_join`选项指定服务器列表。\n- 使用`-retry-join`选项指定服务器列表。\n- 使用`-retry-join`选项对受支持的云环境使用标记自动连接。\n\n","tags":["consul"]},{"title":"java keytool 创建 jks 证书","url":"/2018/12/03/java-keytool-创建-jks-证书/","content":"\n### 环境\n\njava ： jdk1.8\n证书库：用于在本地测试的证书库，域名为：locahost。\n证书库密码：密码为“localhost”。\n证书库位置：当前路径\n证书库文件名：localhost.jks\n证书库格式：JKS\n\n### 生成证书\n\nLinux 系统\n```shell\nkeytool -genkeypair  -alias localhost \\\n        -keyalg RSA -keysize 4096 -keypass localhost \\\n        -sigalg SHA256withRSA \\\n        -keystore localhost.jks -storetype JKS -storepass localhost \\\n        -dname \"cn=localhost,ou=localhost,o=localhost,l=beijing,st=beijing,c=cn\" \\\n        -validity 36500\n```\n\nWindows 系统\n```cmd\nkeytool -genkeypair  -alias localhost ^\n        -keyalg RSA -keysize 4096 -keypass localhost ^\n        -sigalg SHA256withRSA ^\n        -keystore localhost.jks -storetype JKS -storepass localhost ^\n        -dname \"cn=localhost,ou=localhost,o=localhost,l=beijing,st=beijing,c=cn\" ^\n        -validity 36500\n```\n\n### 查看证书\n\n```shell\nkeytool -list -keystore localhost.jks -storetype JKS -storepass localhost\n```\n\n### 导出证书\n\n```shell\nkeytool -export -alias localhost \\\n        -file localhost.cer \\\n        -keystore localhost.jks -storetype JKS -storepass localhost\n```\n\n```cmd\nkeytool -export -alias localhost ^\n        -file localhost.cer ^\n        -keystore localhost.jks -storetype JKS -storepass localhost\n```\n\n### 环境\n\njava ： jdk1.8\n证书库：java自带证书库。\n证书库密码：java自带证书库的默认密码为“changeit”。\njdk安装位置：C:\\Program Files\\Java\\jdk1.8.0_144\\\n证书库位置：C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\security\\\n证书库文件名：cacerts\n\n### 查看证书库\n\n```\nkeytool -list -keystore \"C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\security\\cacerts\" -storetype JKS -storepass changeit\n```\n\n### 查看证书库中证书详情\n```\n//打印所有证书的详情\nkeytool -list -v -keystore \"C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\security\\cacerts\" -storetype JKS -storepass changeit\n//打印某一个证书的详情\nkeytool -list -v -alias <证书别名，需要替换> -keystore \"C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\security\\cacerts\" -storetype JKS -storepass changeit\n```\n\n### 导入证书\n\n```\nkeytool -import -keystore \"C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\security\\cacerts\" -storetype JKS -storepass changeit -file <证书文件，需要替换，不知道相对路径时，可以使用绝对路径> -alias <证书别名，需要替换，自己起一个有含义的名字即可>\n```","tags":["java"]},{"title":"Gradle快速指南","url":"/2018/11/30/gradle快速指南/","content":"\n# Gradle快速指南\n\n> Gradle 是一个基于Ant,Maven的一个非常年轻，强大，灵活的新一代java构建工具，并且正在支持更多语言\n\n## 核心概念 & 术语\n\n- project\n- task\n- Ant task\n- Lifecycle\n- dependencies\n- Plugins\n\n### project | 项目\n项目指你要构建的一切东西。它可以是一个java项目，可以是一个jar包，zip包。项目不一定代表要构建的东西。它可能表示要完成的一件事情，例如将应用程序部署到暂存或生产环境。\n\n### task | 任务\n每个项目都由一个或多个任务组成。任务表示构建执行的一些原子工作。这可能是编译一些类、创建一个JAR、生成Javadoc或将一些归档发布到存储库。\n\nGroovy声明任务\n```groovy\ntask hello {\n    doLast {\n        println 'Hello world!'\n    }\n}\n```\n\n运行\n\n```\nE:\\coding_repository\\gradle-learning>gradle hello\n\n> Task :hello\nHello world!\nGreetings from the hello task.\n\nBUILD SUCCESSFUL in 2s\n1 actionable task: 1 executed\n\n```\n\n### Ant task | Ant任务\n特指Ant的任务，Gradle可以调用Ant任务\n\nAnt 任务\n\n`./antLoadfileResources/build.xml`\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<project name=\"HelloWorld\" default=\"run\" basedir=\".\">\n    <property name=\"src\" value=\"src\"/>\n    <property name=\"dest\" value=\"classes\"/>\n    <property name=\"hello_jar\" value=\"hello1.jar\"/>\n    <target name=\"init\">\n        <mkdir dir=\"${dest}\"/>\n    </target>\n    <target name=\"compile\" depends=\"init\">\n        <javac srcdir=\"${src}\" destdir=\"${dest}\"/>\n    </target>\n    <target name=\"build\" depends=\"compile\">\n        <jar jarfile=\"${hello_jar}\" basedir=\"${dest}\"/>\n    </target>\n    <target name=\"run\" depends=\"build\">\n        <java classname=\"test.ant.HelloWorld\" classpath=\"${hello_jar}\"/>\n    </target>\n    <target name=\"clean\">\n        <delete dir=\"${dest}\" />\n        <delete file=\"${hello_jar}\" />\n    </target>\n    <target name=\"rerun\" depends=\"clean,run\">\n        <ant target=\"clean\" />\n        <ant target=\"run\" />\n    </target>\n</project>\n```\n\n`build.gradle`\n\n```groovy\n// 调用 Ant 任务\ntask loadfile {\n    doLast{\n        def files = file('./antLoadfileResources').listFiles().sort()\n        files.each { File file ->\n            if (file.isFile()) {\n                ant.loadfile(srcFile: file, property: file.name)\n                println \" *** $file.name ***\"\n                println \"${ant.properties[file.name]}\"\n            }\n        }\n    }\n}\n```\n\n\n### Lifecycle | 生命周期\n- Initialization | 初始化 ： \n- Configuration | 配置安装 ：\n- Execution | 执行 ：","tags":["Gradle"]},{"title":"windows申请免费ssl证书","url":"/2017/05/20/windows申请免费ssl证书/","content":"\n\n# windwos\tNginx 使用 win-acme 申请免费SSL证书\n\n### 前置知识——SSL证书\n\n1. **SSL**\n\nSSL( Secure Sockets Layer  [安全套接层](https://baike.baidu.com/item/安全套接层)  ) 是[网景科技](https://baike.baidu.com/item/Netscape)研发的用以保障在Internet上数据传输的安全的技术规范。\n\n2.  **OpenSSL**\n\n简单地说,OpenSSL是SSL的一个实现,SSL只是一种规范.理论上来说,SSL这种规范是安全的,目前的技术水平很难破解,但SSL的实现就可能有些漏洞,如著名的\"心脏出血\".OpenSSL还提供了一大堆强大的工具软件,强大到90%我们都用不到. \n\n3. **证书标准**\n\nX.509 - 这是一种证书标准,主要定义了证书中应该包含哪些内容.其详情可以参考RFC5280,SSL使用的就是这种证书标准.\n\n4. **编码格式**\n\n同样的X.509证书,可能有不同的编码格式,目前有以下两种编码格式.\n\nPEM - Privacy Enhanced Mail,打开看文本格式,以\"-----BEGIN...\"开头, \"-----END...\"结尾,内容是BASE64编码.\n查看PEM格式证书的信息:`openssl x509 -in certificate.pem -text -noout`\nApache和*NIX服务器偏向于使用这种编码格式.\n\nDER - Distinguished Encoding Rules,打开看是二进制格式,不可读.\n查看DER格式证书的信息:`openssl x509 -in certificate.der -inform der -text -noout`\nJava和Windows服务器偏向于使用这种编码格式.\n\n5. **相关的文件扩展名**\n\n这是比较误导人的地方,虽然我们已经知道有PEM和DER这两种编码格式,但文件扩展名并不一定就叫\"PEM\"或者\"DER\",常见的扩展名除了PEM和DER还有以下这些,它们除了编码格式可能不同之外,内容也有差别,但大多数都能相互转换编码格式. \n\n**CRT** - CRT应该是certificate的三个字母,其实还是证书的意思,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码,相信你已经知道怎么辨别.\n\n**CER** - 还是certificate,还是证书,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.\n\n**KEY** - 通常用来存放一个公钥或者私钥,并非X.509证书,编码同样的,可能是PEM,也可能是DER.\n查看KEY的办法:`openssl rsa -in mykey.key -text -noout`\n如果是DER格式的话,同理应该这样了:`openssl rsa -in mykey.key -text -noout -inform der`\n\n**CSR** - Certificate Signing Request,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好.做过iOS APP的朋友都应该知道是怎么向苹果申请开发者证书的吧.\n查看的办法:`openssl req -noout -text -in my.csr` (如果是DER格式的话照旧加上-inform der,这里不写了)\n\n**PFX/P12** - predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个\"提取密码\",你想把里面的东西读取出来的话,它就要求你提供提取密码,PFX使用的时DER编码,如何把PFX转换为PEM编码？\n`openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes`\n这个时候会提示你输入提取代码. for-iis.pem就是可读的文本.\n生成pfx的命令类似这样:`openssl pkcs12 -export -in certificate.crt -inkey privateKey.key -out certificate.pfx -certfile CACert.crt`\n\n其中CACert.crt是CA(权威证书颁发机构)的根证书,有的话也通过-certfile参数一起带进去.这么看来,PFX其实是个证书密钥库.\n\n**JKS** - 即Java Key Storage,这是Java的专利,跟OpenSSL关系不大,利用Java的一个叫\"keytool\"的工具,可以将PFX转为JKS,当然了,keytool也能直接生成JKS,不过在此就不多表了.\n\n6. **证书编码的转换**\n\n**PEM转为DER** `openssl x509 -in cert.crt -outform der -out cert.der`\n\n**DER转为PEM** `openssl x509 -in cert.crt -inform der -outform pem -out cert.pem`\n\n(提示:要转换KEY文件也类似,只不过把x509换成rsa,要转CSR的话,把x509换成req...)\n\n7. **获得证书**\n\n**向权威证书颁发机构申请证书**\n\n用这命令生成一个csr: `openssl req -newkey rsa:2048 -new -nodes -keyout my.key -out my.csr`\n把csr交给权威证书颁发机构,权威证书颁发机构对此进行签名,完成.保留好csr,当权威证书颁发机构颁发的证书过期的时候,你还可以用同样的csr来申请新的证书,key保持不变.\n\n**或者生成自签名的证书\n\n**`openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem`\n在生成证书的过程中会要你填一堆的东西,其实真正要填的只有Common Name,通常填写你服务器的域名,如\"yourcompany.com\",或者你服务器的IP地址,其它都可以留空的.\n生产环境中还是不要使用自签的证书,否则浏览器会不认,或者如果你是企业应用的话能够强制让用户的浏览器接受你的自签证书也行.向权威机构要证书通常是要钱的,但现在也有免费的,仅仅需要一个简单的域名验证即可.有兴趣的话查查\"沃通数字证书\".\n\n### 使用 win-acme 申请免费SSL证书\n\n 项目地址：https://github.com/PKISharp/win-acme \n\n下载稳定版本，不要最新的，可能有BUG\n\n![1553846676556293](./1553846676556293.png)\n\n如果服务器有iis并且开启的话可以直接“N”直接快捷创建，里面输入你网站的域名即可，域名要先提前关联上IP无脑下一步会自动把证书配置到IIS中，并且开启443端口，如果是阿里云类似的有防火墙的需要配置一下。\n\n然后如果想要找到证书相关目录，在\n\n```cmd\nC:\\ProgramData\\win-acme\\acme-v02.api.letsencrypt.org\\Certificates\n```\n\n中可以找到。另外一些内容是在读软件wiki中发现的。默认生成的证书如果在IIS中选择导出，是不能导出私钥的。\n\n如果未来有需求需要导出，需要修改软件目录下的“settings.config”找到“PrivateKeyExportable”修改下面的value为True。\n\n![](./1553847110969497.png)\n\n**不使用IIS，使用Nginx**\n\n至于我的需求就很难受，因为我不是iis中使用，需要PEM文件，而生成的即使导出了也包含私钥了，还是pfx文件，如果转换的话需要openssl，又要安装其他软件。\n\n通过阅读wiki发现软件有这么一个选项\n\n![](./1553847388828422.png)\n\n\"DefaultPemFilesPath\"这个参数通过添加值，可以生成PEM文件的证书和私钥，可以直接导入到相关程序中。方法如下：\n\n  首先我们来到主页面，点击\"M\"使用高级模式\n\n![](./1553847515271943.png)\n\n 紧接着我们使用自定义输入名称，也没有其他选择 \n\n![](./1553847555934545.png)\n\n 这个名称是域名，跟最上面写的一样，需要提前解析好紧接着我们使用“4”也就是默认的验证方法。 \n\n![](./1553847626888932.png)\n\n 选择“2”使用完整的RSA \n\n![](./1553847685205962.png)\n\n 注意：使用第三个，也就是生成PEM文件供其他软件使用。 \n\n![](./1553847744341878.png)\n\n 这一步我选择2之后就卡住了，所以我只能选择第一个 \n\n![](./1553847809743655.png)\n\n然后提示输入文件目录，会生成证书","tags":["SSL"]},{"title":"Java实现二叉搜索树算法（BST）","url":"/2016/11/01/Java实现二叉搜索树算法（BST）/","content":"\n\n### 一、树 & 二叉树\n\n树是由节点和边构成，储存元素的集合。节点分根节点、父节点和子节点的概念。\n如图：树深=4; 5是根节点；同样8与3的关系是父子节点关系。\n<img src=\"./Image1.png\" style=\"width:70%;height:70%;\">\n\n二叉树binary tree，则加了“二叉”（binary），意思是在树中作区分。每个节点至多有两个子（child）,left child & right child。二叉树在很多例子中使用，比如二叉树表示算术表达式。\n如图：1/8是左节点；2/3是右节点；\n\n<img src=\"./Image2.png\" style=\"width:70%;height:70%;\">\n\n### 二、二叉搜索树 BST\n\n顾名思义，二叉树上又加了个搜索的限制。其要求：每个节点比其左子树元素大，比其右子树元素小。如图：每个节点比它左子树的任意节点大，而且比它右子树的任意节点小\n\n<img src=\"./Image3.png\" style=\"width:70%;height:70%;\">\n\n### 三、BST Java实现\n\nBinarySearchTree.java\n\n```java\n/*\n * Copyright [2015] [Jeff Lee]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * 二叉搜索树(BST)实现\n * <p>\n * Created by bysocket on 16/7/7.\n */\npublic class BinarySearchTree {\n    /**\n     * 根节点\n     */\n    public static TreeNode root;\n\n    public BinarySearchTree() {\n        this.root = null;\n    }\n\n    /**\n     * 查找\n     * 树深(N) O(lgN)\n     * 1. 从root节点开始\n     * 2. 比当前节点值小,则找其左节点\n     * 3. 比当前节点值大,则找其右节点\n     * 4. 与当前节点值相等,查找到返回TRUE\n     * 5. 查找完毕未找到,\n     *\n     * @param key\n     * @return\n     */\n    public TreeNode search(int key) {\n        TreeNode current = root;\n        while (current != null\n                && key != current.value) {\n            if (key < current.value)\n                current = current.left;\n            else\n                current = current.right;\n        }\n        return current;\n    }\n\n    /**\n     * 插入\n     * 1. 从root节点开始\n     * 2. 如果root为空,root为插入值\n     * 循环:\n     * 3. 如果当前节点值大于插入值,找左节点\n     * 4. 如果当前节点值小于插入值,找右节点\n     *\n     * @param key\n     * @return\n     */\n    public TreeNode insert(int key) {\n        // 新增节点\n        TreeNode newNode = new TreeNode(key);\n        // 当前节点\n        TreeNode current = root;\n        // 上个节点\n        TreeNode parent = null;\n        // 如果根节点为空\n        if (current == null) {\n            root = newNode;\n            return newNode;\n        }\n        while (true) {\n            parent = current;\n            if (key < current.value) {\n                current = current.left;\n                if (current == null) {\n                    parent.left = newNode;\n                    return newNode;\n                }\n            } else {\n                current = current.right;\n                if (current == null) {\n                    parent.right = newNode;\n                    return newNode;\n                }\n            }\n        }\n    }\n\n    /**\n     * 删除节点\n     * 1.找到删除节点\n     * 2.如果删除节点左节点为空 , 右节点也为空;\n     * 3.如果删除节点只有一个子节点 右节点 或者 左节点\n     * 4.如果删除节点左右子节点都不为空\n     *\n     * @param key\n     * @return\n     */\n    public TreeNode delete(int key) {\n        TreeNode parent = root;\n        TreeNode current = root;\n        boolean isLeftChild = false;\n        // 找到删除节点 及 是否在左子树\n        while (current.value != key) {\n            parent = current;\n            if (current.value > key) {\n                isLeftChild = true;\n                current = current.left;\n            } else {\n                isLeftChild = false;\n                current = current.right;\n            }\n\n            if (current == null) {\n                return current;\n            }\n        }\n\n        // 如果删除节点左节点为空 , 右节点也为空\n        if (current.left == null && current.right == null) {\n            if (current == root) {\n                root = null;\n            }\n            // 在左子树\n            if (isLeftChild == true) {\n                parent.left = null;\n            } else {\n                parent.right = null;\n            }\n        }\n        // 如果删除节点只有一个子节点 右节点 或者 左节点\n        else if (current.right == null) {\n            if (current == root) {\n                root = current.left;\n            } else if (isLeftChild) {\n                parent.left = current.left;\n            } else {\n                parent.right = current.left;\n            }\n\n        } else if (current.left == null) {\n            if (current == root) {\n                root = current.right;\n            } else if (isLeftChild) {\n                parent.left = current.right;\n            } else {\n                parent.right = current.right;\n            }\n        }\n        // 如果删除节点左右子节点都不为空\n        else if (current.left != null && current.right != null) {\n            // 找到删除节点的后继者\n            TreeNode successor = getDeleteSuccessor(current);\n            if (current == root) {\n                root = successor;\n            } else if (isLeftChild) {\n                parent.left = successor;\n            } else {\n                parent.right = successor;\n            }\n            successor.left = current.left;\n        }\n        return current;\n    }\n\n    /**\n     * 获取删除节点的后继者\n     * 删除节点的后继者是在其右节点树种最小的节点\n     *\n     * @param deleteNode\n     * @return\n     */\n    public TreeNode getDeleteSuccessor(TreeNode deleteNode) {\n        // 后继者\n        TreeNode successor = null;\n        TreeNode successorParent = null;\n        TreeNode current = deleteNode.right;\n\n        while (current != null) {\n            successorParent = successor;\n            successor = current;\n            current = current.left;\n        }\n\n        // 检查后继者(不可能有左节点树)是否有右节点树\n        // 如果它有右节点树,则替换后继者位置,加到后继者父亲节点的左节点.\n        if (successor != deleteNode.right) {\n            successorParent.left = successor.right;\n            successor.right = deleteNode.right;\n        }\n\n        return successor;\n    }\n\n    public void toString(TreeNode root) {\n        if (root != null) {\n            toString(root.left);\n            System.out.print(\"value = \" + root.value + \" -> \");\n            toString(root.right);\n        }\n    }\n}\n\n/**\n * 节点\n */\nclass TreeNode {\n\n    /**\n     * 节点值\n     */\n    int value;\n\n    /**\n     * 左节点\n     */\n    TreeNode left;\n\n    /**\n     * 右节点\n     */\n    TreeNode right;\n\n    public TreeNode(int value) {\n        this.value = value;\n        left = null;\n        right = null;\n    }\n}\n```\n\n1. 节点数据结构\n首先定义了节点的数据接口，节点分左节点引用和右节点引用及本身节点值。如图\n\n<img src=\"./Image4.png\" style=\"width:70%;height:70%;\">\n\n\n2. 插入\n插入，和删除一样会引起二叉搜索树的动态变化。插入相对删处理逻辑相对简单些。如图插入的逻辑：\n\n<img src=\"./Image5.png\" style=\"width:70%;height:70%;\">\n\na. 从root节点开始\nb.如果root为空,root为插入值\nc.循环:\nd.如果当前节点值大于插入值,找左节点\ne.如果当前节点值小于插入值,找右节点\n\n3. 查找\n其算法复杂度 : O(lgN),树深(N)。如图查找逻辑：\n\n<img src=\"./Image6.png\" style=\"width:70%;height:70%;\">\n\na.从root节点开始\nb.比当前节点值小,则找其左节点\nc.比当前节点值大,则找其右节点\nd.与当前节点值相等,查找到返回TRUE\ne.查找完毕未找到\n\n4. 删除\n首先找到删除节点，其寻找方法：删除节点的后继者是在其右节点树种最小的节点。如图删除对应逻辑：\n\n<img src=\"./Image7.png\" style=\"width:70%;height:70%;\">\n\n结果为：\n\n<img src=\"./Image8.png\" style=\"width:70%;height:70%;\">\n\na.找到删除节点\nb.如果删除节点左节点为空 , 右节点也为空;\nc.如果删除节点只有一个子节点 右节点 或者 左节点\nd.如果删除节点左右子节点都不为空代码对应见上面完整代码。\n ","tags":["java","Algorithms"]},{"title":"Java运算符优先级表","url":"/2016/10/24/Java运算符优先级表/","content":"\n\n<img src=\"./Image.png\" style=\"width:70%;height:70%;\">","tags":["java"]},{"title":"算法分析（五）——平摊分析介绍","url":"/2016/10/14/算法分析（五）——平摊分析介绍/","content":"\n> 平摊分析用于那些偶尔运算很慢，但大多数其他运算都很快的算法。在平摊分析中，我们分析一个操作序列，并保证一个最坏情况下的平均时间比一个特定的昂贵操作的最坏情况下的时间低。\n\n使用平摊分析分析操作的示例数据结构有散列表、不相交集和散列树。\n\n让我们考虑一个简单哈希表插入的例子。如何确定表的大小?\n空间和时间之间存在权衡，如果我们让散列表的大小变大，搜索时间会变快，但所需的空间会变大。\n\n<img src=\"./Dynamic-Table.png\" style=\"width:50%;height:50%;float:right;\">\n\n这个折衷问题的解决方案是使用动态表(或数组)。这个想法是在表满的时候增加表的大小。下面是表满时要执行的步骤。\n\n1)为较大的表分配内存，通常是旧表的两倍。\n2)将旧表的内容复制到新表中。\n3)清理旧表。\n\n如果表有可用空间，我们只需在可用空间中插入新项。\n\n使用上述方案，n个插入的时间复杂度是多少?\n\n如果我们使用简单的分析，最坏的情况下插入成本是O(n)。\n因此，最坏情况下n个插入的代价是n * O(n) 也就是O(n<sup>2</sup>)\n这一分析给出了上界,但不是一个严格的上限为n插入所有插入不要Θ(n)。\n\n\n<img src=\"./AmortizedAnalysis.png\" style=\"width:50%;height:50%;\">\n\n因此，利用平摊分析，我们可以证明动态表方案具有O(1)插入时间，这是一个很好的哈希结果。\n此外，动态表的概念在c++中用于向量，在Java中用于ArrayList。\n\n\n以下是一些重要的注意事项。\n\n1) 操作序列的平摊成本可以看作是受薪人员的支出。一个人的月平均消费低于或等于工资，但这个人可以在一个特定的月份花更多的钱来买一辆车或其他东西。\n   在其他月份，他或她会为昂贵的月份存钱。\n2) 上述对动态数组实例的平摊分析称为聚合法。有两种更强大的方法来做平摊分析，分别是会计方法和势能方法。我们将在不同的文章中讨论另外两种方法。\n3) 平摊分析不涉及概率。还有另一个关于平均情况运行时间的不同概念，算法使用随机化使它们更快，并且期望运行时间比最坏情况运行时间更快。这些算法采用随机分析。这些算法的例子有随机快速排序、快速选择和哈希。我们很快将在另一篇文章中报道随机分析。\n\n","tags":["Algorithms"]},{"title":"算法分析（四）——解递归式","url":"/2016/09/29/算法分析（四）——解递归式/","content":"\n\n> 在前一篇文章中，我们讨论了循环的分析。许多算法本质上是递归的。当我们分析它们时，我们得到了时间复杂度的递归关系。我们得到运行时间对于大小为n的输入是n的函数，对于较小的输入是运行时间。例如，在归并排序中，为了对给定的数组进行排序，我们将它分成两半，然后递归地重复这一过程。最后我们合并结果。归并排序的时间复杂度可以写成T(n) = 2T(n/2) + cn。还有许多其他的算法，如二分查找、汉诺塔等。\n\n解递归主要有三种方法。\n\n### 1)代换法\n先对解进行猜测，然后用数学归纳法来证明猜测的正确与否。\n\n```\nFor example consider the recurrence T(n) = 2T(n/2) + n\n\nWe guess the solution as T(n) = O(nLogn). Now we use induction\nto prove our guess.\n\nWe need to prove that T(n) <= cnLogn. We can assume that it is true\nfor values smaller than n.\n\nT(n) = 2T(n/2) + n\n    <= cn/2Log(n/2) + n\n    =  cnLogn - cnLog2 + n\n    =  cnLogn - cn + n\n    <= cnLogn\n```\n\n### 2)递归树法\n在此方法中，我们绘制递归树，计算树的每一层所花费的时间。最后，我们总结了各级所做的工作。为了绘制递归树，我们从给定的递归树开始，不断地绘制，直到找到层次之间的模式。模式通常是一个算术或几何级数。\n\n```\nFor example consider the recurrence relation \nT(n) = T(n/4) + T(n/2) + cn2\n\n           cn2\n         /      \\\n     T(n/4)     T(n/2)\n\nIf we further break down the expression T(n/4) and T(n/2), \nwe get following recursion tree.\n\n                cn2\n           /           \\      \n       c(n2)/16      c(n2)/4\n      /      \\          /     \\\n  T(n/16)     T(n/8)  T(n/8)    T(n/4) \nBreaking down further gives us following\n                 cn2\n            /            \\      \n       c(n2)/16          c(n2)/4\n       /      \\            /      \\\nc(n2)/256   c(n2)/64  c(n2)/64    c(n2)/16\n /    \\      /    \\    /    \\       /    \\  \n\nTo know the value of T(n), we need to calculate sum of tree \nnodes level by level. If we sum the above tree level by level, \nwe get the following series\nT(n)  = c(n^2 + 5(n^2)/16 + 25(n^2)/256) + ....\nThe above series is geometrical progression with ratio 5/16.\n\nTo get an upper bound, we can sum the infinite series. \nWe get the sum as (n2)/(1 - 5/16) which is O(n2)\n```\n\n### 3)套用公式法:\n主方法是求解的直接方法。主方法只适用于以下类型的递归或可转换为以下类型的递归。\n\n```\nT(n) = aT(n/b) + f(n) where a >= 1 and b > 1\n```\n\n有以下三种情况:\n1. If f(n) = Θ(n<sup>c</sup>) where c < Log<sub>b</sub>a then T(n) = Θ(n<sup>Log<sub>b</sub>a</sup>)\n\n2. If f(n) = Θ(n<sup>c</sup>) where c = Log<sub>b</sub>a then T(n) = Θ(n<sup>c</sup>Log n)\n\n3. If f(n) = Θ(n<sup>c</sup>) where c > Log<sub>b</sub>a then T(n) = Θ(f(n))\n\n\n#### 这是怎么做到的呢?\n\n套用公式法主要来源于递归树法。如果我们画递归树的T (n) = (n / b) + f (n),我们可以看到,在根所做的工作是f (n)和工作在所有的树叶都是Θc Logba (n<sup>c</sup>)。递归树的高度是Log<sub>b</sub>n\n\n<img src=\"./AlgoAnalysis.png\" style=\"width:70%;height:70%;\">\n\n在递归树法中，我们计算所做的总功。如果工作在叶子多项式,然后叶子是占主导地位的一部分,我们的结果成为了工作在叶子(情况1)。如果工作在叶子和根是一样渐近,那么结果就变得高度乘以各级工作(例2)。如果工作根多是渐近,那么结果就是工作在根(例3)。\n\n#### 一些标准算法的例子，它们的时间复杂度可以用套用公式法来评估\n\n**归并排序**:T (n) = 2 T (n / 2) +Θ(n)。它落在情形2中，因为c是1,Logba也是1。因此,解决方案是Θ(n Logn)\n\n**二进制搜索**:T (n) = T (n / 2) +Θ(1)。当c等于0 Logba也等于0时，它也落在情形2中。所以解决方法是Θ(Logn)\n\n### 注意\n\n1) 用主定理求解T(n) = aT(n/b) + f(n)的递归式是不必要的。给定的三种情况之间有一些差距。例如，递归T(n) = 2T(n/2) + n/Logn不能用主方法求解。\n\n2) 第二种情况可以扩展f (n) =Θ(n<sup>c</sup>Log<sup>k</sup>n)\n如果f (n) =Θ(n<sup>c</sup>Log<sup>k</sup>n)常数k > = 0和c = Logba,然后T (n) =Θ(n<sup>c</sup>Log<sup>k + 1</sup> n)","tags":["Algorithms"]},{"title":"算法分析（四）——分析循环","url":"/2016/08/20/算法分析（四）——分析循环/","content":"\n\n> 我们已经讨论了渐近分析，最坏，平均和最好的情况和渐近符号在以前的文章。在这篇文章中，通过简单的例子讨论了对迭代程序的分析。\n\n### 常见算法复杂度\n\n1. **O(1)** 如果一个函数(或一组语句)不包含循环、递归和对任何其他非常量时间函数的调用，则该函数(或语句集)的时间复杂度被认为是O(1)。\n\n```c\n// 一组非递归和非循环语句\n```\n\n例如，swap()函数的时间复杂度为O(1)。\n一个循环或递归运行一定次数也被认为是O(1)。例如，下面的循环是O(1)。\n\n```c\n    // Here c is a constant   \n    for (int i = 1; i <= c; i++) {  \n        // some O(1) expressions\n    }\n```\n\n2. **O(n)** 如果循环变量增加/减少一个常量，则循环的时间复杂度为O(n)。例如，下列函数的时间复杂度为O(n)。\n\n```c\n   // Here c is a positive integer constant   \n   for (int i = 1; i <= n; i += c) {  \n        // some O(1) expressions\n   }\n\n   for (int i = n; i > 0; i -= c) {\n        // some O(1) expressions\n   }\n\n```\n\n3. **O(n<sup>c</sup>)** 嵌套循环的时间复杂度等于最里面的语句执行的次数。例如，下面的示例循环的时间复杂度为O(n<sup>2</sup>)\n\n```c\n    for (int i = 1; i <=n; i += c) {\n        for (int j = 1; j <=n; j += c) {\n            // some O(1) expressions\n        }\n    }\n\n    for (int i = n; i > 0; i -= c) {\n        for (int j = i+1; j <=n; j += c) {\n            // some O(1) expressions\n    }\n```\n\n例如，选择排序和插入排序的时间复杂度为O(n<sup>2</sup>)。\n\n4. **O(Logn)** 如果循环变量除以/乘以一个常量，则循环的时间复杂度为O(Logn)。\n\n```c\n    for (int i = 1; i <=n; i *= c) {\n        // some O(1) expressions\n    }\n    for (int i = n; i > 0; i /= c) {\n        // some O(1) expressions\n    }\n```\n\n例如，二分查找(引用迭代实现)具有O(Logn)时间复杂度。让我们从数学上看看它是怎样的O(Log n)我们在第一个循环中得到的级数是1,c,c<sup>2</sup>, c<sup>3</sup>, c<sup>k</sup>。如果k等于Logcn，就得到c<sup>Log<sub>c</sub><sup>n</sup></sup>等于n。\n\n5. **O(LogLogn)** 如果一个循环的变量按一定的数量以指数方式减少/增加，则该循环的时间复杂度被认为是O(LogLogn)。\n\n```c\n    // Here c is a constant greater than 1   \n    for (int i = 2; i <=n; i = pow(i, c)) { \n        // some O(1) expressions\n    }\n    //Here fun is sqrt or cuberoot or any other constant root\n    for (int i = n; i > 1; i = fun(i)) { \n        // some O(1) expressions\n    }\n```\n\n有关数学细节，[请参阅此](https://www.geeksforgeeks.org/time-complexity-loop-loop-variable-expands-shrinks-exponentially/)。\n\n\n### 如何合并连续循环的时间复杂度?\n\n当存在连续循环时，我们将时间复杂度计算为单个循环时间复杂度的和。\n\n```c\n    for (int i = 1; i <=m; i += c) {  \n        // some O(1) expressions\n    }\n    for (int i = 1; i <=n; i += c) {\n        // some O(1) expressions\n    }\n    Time complexity of above code is O(m) + O(n) which is O(m+n)\n    If m == n, the time complexity becomes O(2n) which is O(n).   \n```\n\n### 当循环中有许多if, else语句时，如何计算时间复杂度?\n\n正如这里所讨论的，最坏情况的时间复杂度在最佳、平均和最差情况中最有用。因此，我们需要考虑最坏的情况。我们评估if-else条件下的值导致执行的语句数最多的情况。\n\n例如，考虑线性搜索函数，当元素在最后出现或根本不存在时，我们考虑这种情况。\n\n当代码太复杂而不能考虑所有if-else情况时，我们可以通过忽略if else和其他复杂的控制语句来获得一个上限。\n\n### 如何计算递归函数的时间复杂度?\n\n递归函数的时间复杂度可以写成数学递归关系。要计算时间复杂度，我们必须知道如何解递归。我们将很快在另一篇文章中讨论递归求解技术。","tags":["Algorithms"]},{"title":"算法分析（三）——渐进表示法","url":"/2016/07/09/算法分析（三）——渐进表示法/","content":"\n\n> 我们已经讨论了渐近分析、最坏情况、平均情况和最佳情况的算法。渐近分析的主要思想是度量算法的效率，它不依赖于机器特定的常数，不需要实现算法，也不需要比较程序所花费的时间。渐近符号是表示渐近分析算法时间复杂度的数学工具。下面三种渐近符号是用来表示算法的时间复杂度的。\n\n<img src=\"./AlgoAnalysis-1.png\" style=\"width:30%;height:30%;float:right;\">\n\n### Θ符号\n\n**Θ符号**:θ符号从上到下界定了一个函数，所以它定义了确切的渐近行为。\n得到表达式符号的一个简单方法是去掉低阶项，忽略前置常数。例如，考虑下面的表达式。\n3 n<sup>3</sup> + 6 n<sup>2</sup> + 6000 =Θ(n<sup>3</sup>)\n把低阶项总是很好,因为总是会有n0之后Θ(n<sup>3</sup>)值高于Θn<sup>3</sup>)无关的常数。\n对于一个给定的函数g (n),我们表示Θ(g (n))是后组功能。\n\n\n\n```\nΘ(g(n)) = {f(n): there exist positive constants c1, c2 and n0 such \n                 that 0 <= c1*g(n) <= f(n) <= c2*g(n) for all n >= n0}\n```\n\n\n\n上面的定义意味着，如果f(n)是Θ(g(n))，那么对于n (n >= n0)较大的值，f(n)总是在c1*g(n)和c2*g(n)之间。的定义还要求当n大于n0时，f(n)必须是非负的。\n\n<img src=\"./AlgoAnalysis-2.png\" style=\"width:30%;height:30%;float:right;\">\n\n### 大O符号\n\n**大O符号**:大O符号定义了一个算法的上界，它只从上面限定一个函数。例如，考虑插入排序的情况。最好的情况是线性时间最坏的情况是二次时间。我们可以有把握地说插入排序的时间复杂度是O(n^2)。注意，O(n²)也包括线性时间。\n如果我们使用Θ符号来表示插入排序的时间复杂度,我们必须使用两个语句最好和最差情况下:\n\n   1. 最坏的情况下插入排序的时间复杂度是Θ(n ^ 2)。\n   2. 最好的情况下插入排序的时间复杂度是Θ(n)。\n   \n当我们只有算法时间复杂度的上界时，大O符号是有用的。很多时候，我们很容易通过简单的算法找到一个上界。\n\n\n```\nO(g(n)) = { f(n): there exist positive constants c and \n                  n0 such that 0 <= f(n) <= c*g(n) for \n                  all n >= n0}\n```\n\n<img src=\"./AlgoAnalysis-3.png\" style=\"width:30%;height:30%;float:right;\">\n\n### Ω符号\n\n**Ω符号**:正如大O符号功能,提供了一个渐近上限Ω符号提供了一个渐近下界。\nΩ符号可以是有用的,当我们对一个算法的时间复杂度有下界。正如在前一篇文章中所讨论的，算法的最佳性能通常是无用的，Omega表示法是这三种表示法中使用最少的。\n\n对于一个给定的函数g (n),我们表示Ω(g (n))的一组功能。\n\n\n```\nΩ (g(n)) = {f(n): there exist positive constants c and\n                  n0 such that 0 <= c*g(n) <= f(n) for\n                  all n >= n0}.\n```\n\n让我们考虑这里相同的插入排序示例。插入排序的时间复杂度可以写成Ω(n),但它不是一个非常有用的信息插入排序,我们通常感兴趣的最坏情况,有时在平均情况下。\n\n","tags":["Algorithms"]},{"title":"算法分析（二）——最坏、平均和最好的情况","url":"/2016/06/02/算法分析（二）——最坏、平均和最好的情况/","content":"\n> 在前一篇文章中，我们讨论了渐近分析是如何克服单纯分析算法的问题的。在这篇文章中，我们将以线性搜索为例，用渐近分析进行分析。\n\n我们可以用三种情况来分析一个算法:\n1. 最坏情况\n2. 平均情况\n3. 最好的情况\n\n让我们考虑以下线性搜索的实现。\n```C++\n// C++ implementation of the approach \n#include <bits/stdc++.h> \nusing namespace std; \n\n// Linearly search x in arr[]. \n// If x is present then return the index, \n// otherwise return -1 \nint search(int arr[], int n, int x) \n{ \n\tint i; \n\tfor (i=0; i<n; i++) \n\t{ \n\tif (arr[i] == x) \n\t\treturn i; \n\t} \n\treturn -1; \n} \n\n// Driver Code \nint main() \n{ \n\tint arr[] = {1, 10, 30, 15}; \n\tint x = 30; \n\tint n = sizeof(arr)/sizeof(arr[0]); \n\tcout << x << \" is present at index \"\n\t\t\t<< search(arr, n, x); \n\n\tgetchar(); \n\treturn 0; \n} \n\n// This code is contributed \n// by Akanksha Rai \n\n   ```\n\n   Output:\n   ```\n   30 is present at index 2\n   ```\n\n### 最坏情况分析(最常用)\n\n在最坏的情况下，我们计算算法运行时间的上界。我们必须知道导致执行最多操作数的情况。对于线性搜索，最坏的情况是要搜索的元素(上面代码中的x)不在数组中。当x不存在时，search()函数将它与arr[]的所有元素逐个进行比较。因此,最坏情况下的时间复杂度线性搜索将Θ(n)。\n\n### 平均情况(一般常用)\n\n在平均情况分析中，我们使用所有可能的输入并计算所有输入的计算时间。将所有计算值相加并除以输入的总数。我们必须知道(或预测)病例的分布。对于线性搜索问题，我们假设所有的情况都是均匀分布的(包括x不在数组中的情况)。我们把所有的情况加起来然后除以(n+1)下面是平均案例时间复杂度的值。\n\n>Average Case Time = <img src=\"./analysis1.png\" style=\"width:20%;height:20%\">\n>\n>    = <img src=\"./analysis2.png\" style=\"width:20%;height:20%\">\n> \n>    = Θ(n)\n\n### 最好情况(理想情况)\n\n在最佳情况下，我们计算算法运行时间的下界。我们必须知道导致执行最少操作数的情况。在线性搜索问题中，x出现在第一个位置时是最佳情况。在最好的情况下操作的数量是不变的(不依赖于n)。所以时间复杂度在最好的情况下将Θ(1)\n大多数时候，我们做最坏情况分析来分析算法。在最坏的情况下，我们保证算法运行时间的一个上界，这是一个很好的信息。\n\n一般的案例分析在大多数实际案例中并不容易做到，而且很少有人去做。在平均情况分析中，我们必须知道(或预测)所有可能输入的数学分布。\n最好的案例分析是虚假的。保证算法的下界不提供任何信息，因为在最坏的情况下，算法可能需要数年才能运行。\n\n对于某些算法，所有的情况都是渐近相同的，即。没有最好和最坏的情况。例如，归并排序。归并排序是Θ(nLogn)操作在所有情况下。大多数其他排序算法都有最差和最好的情况。\n例如，在典型的快速排序实现中(选择pivot作为角元素)，最坏的情况发生在输入数组已经排序时，最好的情况发生在主元素总是将数组分成两半时。\n对于插入排序，最坏的情况发生在数组反向排序时，而最好的情况发生在数组按与输出相同的顺序排序时。\n\n\n\n","tags":["Algorithms"]},{"title":"算法分析（一）——渐进分析","url":"/2016/05/29/算法分析（一）——渐进分析/","content":"\n\n> 这篇文章讨论算法分析的重要性和方法\n\n### 为什么要进行性能分析?\n\n在软件开发中有许多重要的事情需要注意，比如用户友好性、模块化、安全性、可维护性等。为什么要担心性能呢?\n这个问题的答案很简单，只有当我们有性能时，我们才能拥有上面所有的东西。因此，性能就像钱，我们可以通过它买到上述所有东西。\n研究性能优化的另一个原因是————速度很有趣!\n\n总而言之，性能==规模。想象一下，一个文本编辑器可以加载1000页，但可以每分钟检查一页的拼写，或者一个图像编辑器需要1个小时来将图像向左旋转90度，或者……如果一个软件特性不能处理用户需要执行的大量任务，那么它就等于死了。\n\n### 给定一个任务的两种算法，我们如何找出哪一种更好?\n\n一种简单的方法是————实现这两种算法，并在您的计算机上运行这两个程序以获得不同的输入，然后查看哪个花费的时间更少。这种算法分析方法存在很多问题。\n- 对于某些输入，第一种算法可能比第二种算法执行得更好。对于某些输入，第二种算法表现得更好。\n- 也有可能，对于某些输入，第一种算法在一台机器上执行得更好，第二种算法在另一台机器上执行得更好。\n  \n渐近分析是分析算法中处理上述问题的重要思想。在渐近分析中，我们根据输入大小来评估算法的性能(我们不测量实际的运行时间)。我们计算，一个算法所花费的时间(或空间)是如何随着输入的大小而增加的。\n例如，让我们考虑排序数组中的搜索问题(搜索给定的项)。一种是线性搜索(增长的顺序是线性的)，另一种是二分搜索(增长的顺序是对数的)。为了理解渐近分析是如何解决上述算法分析中的问题，假设我们在快速计算机上运行线性搜索，在慢速计算机上运行二进制搜索。对于输入数组大小为n的小值，运行速度快的计算机可能花费更少的时间。但是，在输入数组大小达到一定值之后，即使在运行速度较慢的机器上运行二进制搜索，与线性搜索相比，二进制搜索所花费的时间也肯定会减少。原因是二分搜索的增长顺序是对数的，而线性搜索的增长顺序是线性的。因此，与机器相关的常量在输入大小确定之后总是可以忽略。\n\n### 渐近分析总是有效吗?\n渐近分析并不完美，但这是分析算法的最佳方法。例如，假设有两种排序算法，它们在一台机器上分别花费了1000nLogn和2nLogn时间。这两种算法是渐近相同的(增长的顺序是nLogn)。所以，对于渐近分析，我们不能判断哪个更好因为我们在渐近分析中忽略了常数。\n\n同样，在渐近分析中，我们总是讨论输入规模大于常数值。可能这些大的输入从来没有给你的软件和算法是渐进缓慢的，总是表现更好，为你的特定情况。因此，您最终可能会选择一个渐进地更慢但对您的软件更快的算法。","tags":["Algorithms"]}]